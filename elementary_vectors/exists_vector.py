#############################################################################
#  Copyright (C) 2021                                                       #
#                Marcus Aichmayr (aichmayr.marcus@gmail.com)                #
#                                                                           #
#  Distributed under the terms of the GNU General Public License (GPL)      #
#  either version 3, or (at your option) any later version                  #
#                                                                           #
#  http://www.gnu.org/licenses/                                             #
#############################################################################

from elementary_vectors import elementary_vectors

# Todo: If True and certificate is True, compute a corresponding vector of the vector space. (witness)
def exists_vector(data, L, R, l=True, r=True, kernel=False, certificate=False):
    r"""
    Returns whether a vector exists in the vector space determined by a matrix
    such that the components lie in given intervals.
    
    INPUT:
    
    - ``data`` -- either a real matrix with ``n`` columns or a list of
                  elementary vectors of length ``n``
    
    - ``L`` -- a list of real values (``-oo`` and ``oo`` are accepted) of length ``n``
    
    - ``R`` -- a list of real values (``-oo`` and ``oo`` are accepted) of length ``n``
    
    - ``l`` -- a boolean (default: ``True``) or a list of booleans of length ``n``
    
    - ``r`` -- a boolean (default: ``True``) or a list of booleans of length ``n``
    
    - ``kernel`` -- a boolean (default: ``False``)
    
    - ``certificate`` -- a boolean (default: ``False``)
    
    OUTPUT:
    
    - If ``data`` is a matrix, then the elementary vectors of ``M`` are computed.
    
        - If ``kernel`` is false, considers the vector space generated by the
          rows of the matrix ``M``. (default)
          In this case, the elementary vectors will lie in the kernel of ``M``.
          
        - If ``kernel`` is true, considers the vector space generated by the
          kernel of the matrix ``M``.
          In this case, the elementary vectors will lie in the row space of ``M``.

    - If ``data`` is a list of elementary vectors, then those will be used.
    
        - In this case, the argument ``kernel`` will be ignored.

    - ``L`` and ``R`` are the left and right interval values, respectively.
    
    - ``l`` and ``r`` determine the intervals.
    
    - The left (or right) interval half of the ``i``-th interval is
    
        - closed if ``l[i]`` (or ``r[i]``) is ``True`` (default).

        - open if ``l[i]`` (or ``r[i]``) is ``False``.
            
    - If ``l`` (or ``r``) is a boolean, then all left (or right) interval halves
      are considered closed if ``True`` (default) and open if ``False``.
    
    - If ``certificate`` is ``False`` (default), returns a boolean.
    
    - If ``certificate`` is ``True`` and the result is false, then a list
      ``[False, v]`` will be returned. Here, ``v`` is an elementary vector of ``M``
      that certifies that there exists no vector.
    """
    
    if isinstance(data, list):
        evs = data
    else:
        evs = elementary_vectors(data, kernel = not kernel)
    
    if evs == []:
        return True
    
    n = len(evs[0])
    
    if len(L) != n:
        raise ValueError('list ``L`` has wrong length')
    if len(R) != n:
        raise ValueError('list ``R`` has wrong length')
    
    if l == True:
        l = [True for i in range(n)]
    elif l == False:
        l = [False for i in range(n)]
    elif len(l) != n:
        raise ValueError('list ``l`` has wrong length')
    
    if r == True:
        r = [True for i in range(n)]
    elif r == False:
        r = [False for i in range(n)]
    elif len(r) != n:
        raise ValueError('list ``r`` has wrong length')
    
    # is this needed?
    for i in range(n):
        if L[i] == R[i]: # interval is a point
            if l[i] == False:
                return False
            elif r[i] == False:
                return False
    
    if certificate:
        def out_false(v):
            return [False, v]
    else:
        def out_false(v):
            return False

    for v in evs:
        UB = 0
        LB = 0
        UBeq = True
        LBeq = True
        for i in range(n):
            # multiplication following 0 * oo = 0
            a = 0 if v[i] == 0 or L[i] == 0 else v[i]*L[i]
            b = 0 if v[i] == 0 or R[i] == 0 else v[i]*R[i]

            if a == b and v[i] != 0:
                LB += a
                UB += b
                LBeq = LBeq and l[i] and r[i]
                UBeq = UBeq and l[i] and r[i]
            elif a < b:
                LB += a
                UB += b
                LBeq = LBeq and l[i]
                UBeq = UBeq and r[i]
            elif a > b:
                LB += b
                UB += a
                LBeq = LBeq and r[i]
                UBeq = UBeq and l[i]
        
        if LBeq == True:
            if LB > 0:
                return out_false(v)
        elif LB >= 0: # == oder >=?
            return out_false(v)

        if UBeq == True:
            if UB < 0:
                return out_false(v)
        elif UB <= 0: # == oder <=?
            return out_false(v)
        
    return True
